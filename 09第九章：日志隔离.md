## 问题：日志隔离

这个章节处理一个相对困难的问题，为在同一个 web 或 EJB 容器运行的多个客户端提供一个隔离的日志环境。在接下来的章节中，"应用" 一词用来表示 web 应用以及 J2EE 应用。在隔离的日志环境中，每个应用将会看到一个不同的 logback 环境。所以一个应用的 logback 配置不会影响到另一个。从技术角度看，每个 web 应用都会保存一份 `LoggerContext` 的独立拷贝。在 logback 中，`LoggerContext` 产生的每个 logger 对象只要在内存中存活，都会被保留。这个问题的一个变体是隔离应用的日志与容器本身的日志。

## 最简单的方法

假设你的容器支持子级优先加载，那么日志隔离可以通过在每个应用中内置一份 slf4j 与 logback 的 jar 包完成。对于 web 应用，将 slf4j 与 logback 的 jar 包放在 *WEB-INF/lib* 文件夹下，这种方式可以有效的赋予每个 web 应用隔离的日志环境。*logback.xml* 文件放在 *WEB-INF/classes*  下，当 logback 被加载进内存时，该配置会被加载。

由于容器提供了类加载器隔离，每个 web 应用将会加载自己拷贝的 `LoggerContext` 以及自己拷贝的 *logback.xml*。

其实，也不全是。有时候你会被迫将 SLF4J 与 logback 的 jar 包放在同一个地方供所有的应用访问。通常，这是因为共享库需要使用 SLF4J。在这种情况下，所有的应用将会共享同一个日志环境。有许多其它的应用场景需要将 SLF4J 与 logback 的 jar 包放在同一个地方，那么所有的应用都会看到，这样就不能通过类加载隔离来对日志环境进行隔离了。但是并不是没有其它的办法，请继续往下阅读。

## 上下文选择器

logback 提供了一种机制为每个单独 SLF4J 实例以及 logback 类加载进内存提供了多个 logger context。当你写下：

```java
Logger logger = LoggerFactory.getLogger("foo");
```

`LoggerFactory` 类中的 `getLogger()` 方法会要求 SLF4J 绑定 `ILoggerFactory`。当 SLF4J 绑定到 logback，会委托 [ContextSelector](https://logback.qos.ch/apidocs/ch/qos/logback/classic/selector/ContextSelector.html) 实例去返回 `ILoggerFactory`。`ContextSelector` 的实现一直都会返回 `LoggerContext` 实例。