## 问题：日志隔离

这个章节处理一个相对困难的问题，为在同一个 web 或 EJB 容器运行的多个客户端提供一个隔离的日志环境。在接下来的章节中，"应用" 一词用来表示 web 应用以及 J2EE 应用。在隔离的日志环境中，每个应用将会看到一个不同的 logback 环境。所以一个应用的 logback 配置不会影响到另一个。从技术角度看，每个 web 应用都会保存一份 `LoggerContext` 的独立拷贝。在 logback 中，`LoggerContext` 产生的每个 logger 对象只要在内存中存活，都会被保留。这个问题的一个变体是隔离应用的日志与容器本身的日志。

## 最简单的方法

假设你的容器支持子级优先加载，那么日志隔离可以通过在每个应用中内置一份 slf4j 与 logback 的 jar 包完成。对于 web 应用，将 slf4j 与 logback 的 jar 包放在 *WEB-INF/lib* 文件夹下，这种方式可以有效的赋予每个 web 应用隔离的日志环境。*logback.xml* 文件放在 *WEB-INF/classes*  下，当 logback 被加载进内存时，该配置会被加载。

由于容器提供了类加载器隔离，每个 web 应用将会加载自己拷贝的 `LoggerContext` 以及自己拷贝的 *logback.xml*。

其实，也不全是。有时候你会被迫将 SLF4J 与 logback 的 jar 包放在同一个地方供所有的应用访问。通常，这是因为共享库需要使用 SLF4J。在这种情况下，所有的应用将会共享同一个日志环境。有许多其它的应用场景需要将 SLF4J 与 logback 的 jar 包放在同一个地方，那么所有的应用都会看到，这样就不能通过类加载隔离来对日志环境进行隔离了。但是并不是没有其它的办法，请继续往下阅读。

## 上下文选择器

logback 提供了一种机制为每个单独 SLF4J 实例以及 logback 类加载进内存提供了多个 logger context。当你写下：

```java
Logger logger = LoggerFactory.getLogger("foo");
```

`LoggerFactory` 类中的 `getLogger()` 方法会要求 SLF4J 绑定 `ILoggerFactory`。当 SLF4J 绑定到 logback，会委托 [ContextSelector](https://logback.qos.ch/apidocs/ch/qos/logback/classic/selector/ContextSelector.html) 实例去返回 `ILoggerFactory`。`ContextSelector` 的实现一直都会返回同一个 `LoggerContext` 实例，也就是默认的 logger context。

你可以通过 *logback.ContextSelector* 这个系统属性指定不同的上下文选择器。假设你想指定 `myPackage.myContextSelector` 这个类的实例为上下文选择器，那么你可以通过如下方式添加一个系统属性：

```java
-Dlogback.ContextSelector=myPackage.myContextSelector
```

这个上下文选择器需要实现 `ContextSelector` 这个接口，并且有一个构造方法，该构造方法仅仅只接收 `LoggerContext` 实例作为参数。

### ContextJNDISelector

logback-classic 附带了一个名为 `ContextJNDISelector` 的选择器，它基于 JNDI 查找的有效数据去选择一个 logger 上下文。这个方法利用 J2EE 规范强制 JNDI 数据分离。因此，同样的环境变量在不同的应用中能够设置不同的值。换句话说，在不同的应用中调用 `LoggerFactory.getLogger()` 不同 logger 上下文中的 logger。即使所有的应用都共享内存中同一个 LoggerFactory 类。这样就能够对你的日志进行隔离。

要开启 `ContextJNDISelector`，需要设置系统属性 *logback.ContextSelector* 为 "JNDI"。如下：

```java
-Dlogback.ContextSelector=JNDI
```

注意，`JNDI ` 是 `ch.qos.logback.classic.selector.ContextJNDISelector` 的缩写形式。

### 在应用中设置 JNDI

在你的每个应用中，你需要为应用命名 logger 上下文。对于 web 应用，通过 *web.xml* 指定 JNDI 环境条目。如果你应用的名字为 "kenobi"，那么你可以添加如下的 XML 元素到你的 web.xml 文件中：

```xml
<env-entry>
  <env-entry-name>logback/context-name</env-entry-name>
  <env-entry-type>java.lang.String</env-entry-type>
  <env-entry-value>kenobi</env-entry-value>
</env-entry>
```

假设你已经开启了 `ContextJNDISelector`，那么将使用一个名为 "kenobi" 的 logger 上下文来为 Kenobi 打印日志。而且，logger 上下文 "kenobi" 会按照约定使用线程上下文类加载器去寻找一个名为 *logback-kenobi.xml* 的配置文件进行初始化。因此，对于例子中 "kenobi" web 应用，应该将 *logback-kenobi.xml* 放在 *WEB-INF/classes* 文件夹下。

只要你喜欢，通过设置 "logback/configuration-resource" JNDI 变量，你可以不按照约定，而是指定一个不同的配置文件。例如，对于 "kenobi" web 应用，如果你想指定配置文件为 *aFolder/my_config.xml* 而不是约定的 *logback-kenobi.xml*，你可以在 web.xml 中添加如下的 xml 元素：

```xml
<env-entry>
  <env-entry-name>logback/configuration-resource</env-entry-name>
  <env-entry-type>java.lang.String</env-entry-type>
  <env-entry-value>aFolder/my_config.xml</env-entry-value>
</env-entry>
```

*my_config.xml* 文件需要放在 *WEB-INF/classes/aFolder/* 下。需要记住的一点是，使用当前线程的上下文类加载来查找配置文件作为 Java 资源。

### 通过 Tomcat 配置 ContextJNDISelector

首先，将 logback 的 jar 包 (logback-classic-1.3.0-alpha4.jar, logback-core-1.3.0-alpha4.jar and slf4j-api-1.8.0-beta1.jar)  放在 Tomcat 全局的类文件夹下。在 Tomcat 6.x 中，这个文件夹是 *$TOMCAT_HOME/lib/*。

系统属性 *logback.ContextSelector* 可以在 *catalina.sh* 脚本中添加如下的行来进行设置。Windows 下为 *catalina.bat*。在 *$TOMCAT_HOME/bin* 文件夹下。

```java
JAVA_OPTS="$JAVA_OPTS -Dlogback.ContextSelector=JNDI"
```

### 应用热部署

当 web 应用被回收或者关闭时，我们强烈推荐关闭现有的 `LoggerContext`，以便正确的进行垃圾回收。logback 附带了一个名为 [`ContextDetachingSCL`](https://logback.qos.ch/xref/ch/qos/logback/classic/selector/servlet/ContextDetachingSCL.html) 的 `ServletContextListener`，用来分离旧 web 应用中的 `ContextSelector` 实例。可以在 *web.xml* 中添加如下的行来指定：

```xml
<listener>
  <listener-class>ch.qos.logback.classic.selector.servlet.ContextDetachingSCL</listener-class>
</listener>
```

**`NOTE`** 大部分的容器会按照声明的顺序调用 `contextInitialized()` 方法，但是按照相反的顺序调用 `contextDestroyed()` 方法。也就是说，如果你在 *web.xml* 中声明了多个 `ServletContextListener`，那么 `ContextDetachingSCL` 应该*第一个*声明，那么在应用关闭的时候，它的 `contextDestroyed()` 方法将会在 *最后* 被调用。

### 更好的性能

当 `ContextJNDISelector` 处于活动状态，每次查找一个 logger，JNDI 查找必须被执行。这样对性能会有影响，特别是当你使用一个非静态的 logger 时。logback 附带了一个名为 [LoggerContextFilter](https://logback.qos.ch/xref/ch/qos/logback/classic/selector/servlet/LoggerContextFilter.html) 的过滤器，为了避免 JNDI 查找的消耗而特意设计。可以通过在 web.xml 中添加如下的行来指定：

```xml
<filter>
  <filter-name>LoggerContextFilter</filter-name>
  <filter-class>ch.qos.logback.classic.selector.servlet.LoggerContextFilter</filter-class>
</filter>
<filter-mapping>
  <filter-name>LoggerContextFilter</filter-name>
  <url-pattern>/*</url-pattern>
</filter-mapping>
```

